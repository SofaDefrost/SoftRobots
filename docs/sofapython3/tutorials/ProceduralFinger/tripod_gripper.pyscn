import Sofa
from stlib3.scene import Scene
from actuated_finger import ActuatedFinger
from actuated_finger import FingerController
from fixing_box import FixingBox
from stlib3.physics.rigid import Sphere


def createScene(rootNode):

	# Define the main architecture of the scene, with a node Modelling, Setting and Simulation
	# Define also the integration method as Euler implicit and the solver as Conjugate Gradient)
	scene = Scene(rootNode,gravity=[0.0,0.0,-9.81],plugins=['SofaSparseSolver', 'SofaOpenglVisual', 'SofaSimpleFem', 'SofaDeformable', 'SofaEngine', 'SofaGeneralRigid', 'SofaRigid','SofaBoundaryCondition','SofaMeshCollision'],
					iterative=True)
	scene.addMainHeader()

	#Define the integration scheme and the solver parameters
	scene.Simulation.TimeIntegrationSchema.rayleighStiffness=0.1 #0.001
	scene.Simulation.TimeIntegrationSchema.rayleighMass=0.001 #0.001
	scene.Simulation.LinearSolver.tolerance=1e-9
	scene.Simulation.LinearSolver.threshold=1e-9
	scene.Simulation.LinearSolver.iterations=50
	# Setting the time step
	rootNode.dt = 0.01

	# Define the default view of the scene on SOFA
	scene.addObject('DefaultVisualManagerLoop')
	scene.VisualStyle.displayFlags = ["showBehaviorModels","showInteractionForceFields","showForceFields","showCollisionModels"]
	# Add a grid on the scene with squares 10mm/10mm
	rootNode.addObject("OglGrid", nbSubdiv=100, size=1)

	# Setup the pipeline for the collision computation
	rootNode.addObject('DefaultPipeline')
	rootNode.addObject('BruteForceBroadPhase')
	rootNode.addObject('BVHNarrowPhase')
	rootNode.addObject('RuleBasedContactManager', responseParams="ks=" + str(100.0),
					  name='Response', response='PenalityContactForceField')
	rootNode.addObject('MinProximityIntersection',name="Proximity",alarmDistance=2e-3,contactDistance=5e-4)

	# Create one actuated finger
	actuatedFinger = ActuatedFinger()
	scene.Modelling.addChild(actuatedFinger)

	# Install an obstacle in the scene/object to grasp
	scene.Modelling.addChild('Obstacle')
	sphereObst = Sphere(scene.Modelling.Obstacle, translation=[30.0e-3, 0.0, 70.0e-3],
                       uniformScale=10e-3,
                       totalMass=0.032,
                       isAStaticObject=True,
						collisionGroup=[4])
	sphereObst.mass.showAxisSizeFactor = 1e-2
	sphereObst.mstate.name='dofs'
	# Fix the object in space
	fixSphere = FixingBox(scene.Modelling.Obstacle, sphereObst, translation=[30.0e-3, 0.0, 70.0e-3], scale=[10e-3, 10e-3, 10e-3])
	scene.Modelling.Obstacle.FixingBox.BoxROI.drawBoxes = True

	# Add the simulated elements to the Simulation node
	scene.Simulation.addChild(actuatedFinger)
	scene.Simulation.addChild(actuatedFinger.RigidifiedStructure)
	scene.Simulation.addChild(actuatedFinger.ActuatedArm)

	# Add a controller to output some performance metric during the simulation
	scene.addObject(FingerController(name='FingerController',objectDof=sphereObst.collision.MechanicalObject,actuator=scene.Modelling.ActuatedFinger.ActuatedArm,node=rootNode))

	return rootNode
